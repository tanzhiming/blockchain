# 系统架构

区块链是一个分布式系统，由许多相互通信的节点组成。区块链运行的程序称为链码，保存状态和账本数据、执行交易。链码是核心要素，交易操作在链码上调用。交易必须被“背书”，只有经过背书的交易才可以提交，并对状态产生影响。有可能存在一个或多个特定的链码用于管理功能和参数，统称为系统链码。

## 交易(Transactions)

* 部署交易(Deploy transactions)

  部署交易创建新的链码并设置一个程序作为参数。当一个部署交易执行成功，表明链码已被安装到区块链上。

* 调用交易(Invoke transactions)

  调用交易是在之前已部署链码的情况下执行一个操作。调用交易引用链码提供的一个函数。当成功时，链码执行特定的函数-它可能涉及修改相应的状态，并返回一个输出。


## 区块链数据结构

* 状态(State)

  区块链的最新状态（简称为，状态）被建模为一个版本键/值存储（KVS）

  `s: K->(V X N)`
  
  * K 是一组键
  * V 是一组值
  * N 是无限有序版本号集, 内射函数 next: N -> N

  操作模型

  * `put(k, v)`, k ∈ K 且 v ∈ V,  区块链的的状态有`s`转换到`s'`, 这样`s'(k)=(v, next(s(k).version))`,  对于所有 `k'!=k` 有 `s'(k')=s(k')`
  * `get(k)` 返回 `s(k)` 

* 账本(Ledger)

  账本提供了在系统运行过程中发生的可验证历史，它包含所有成功的状态更改（我们称为有效交易）和不成功的状态更改尝试（我们称为无效交易）。

  账本是由排序服务构建的一个全部有序的交易哈希链块（有效的或无效的）。哈希链强制将全部排序块置入账本，每个块包含一批全部排序交易。这个强制全部排序覆盖所有交易。

  账本保存在所有peer节点，可选地，保存在排序者的一个子集。在谈论排序时我们说的账本是排序账本，而谈论peer节点时我们说的账本是peer账本。peer账本与排序账本的区别是，peer节点本地维护一个位掩码来表明隔离有效交易和无效交易。

  账本允许peer节点重演所有交易的历史和重建状态。

## 节点

有三种类型的节点:

* 客户端(Client)：客户端提交实际交易调用到背书者，广播交易请求到排序服务节点。
* Peer节点：提交交易、维持状态和账本的拷贝。此外，peer节点可以有一个特殊的背书角色。
* 排序服务节点(Orderer)：运行通信服务实现交付保证，像原子或全序广播。


### Client节点

客户端代表最终用户实体。它必须连接到一个peer节点以便与区块链交互。客户端可以选择连接任何peer节点。客户端创建并调用交易。

### Peer节点

Peer节点以块的形式从排序服务接收有序状态更新，维护状态和账本。

Peer节点能附加一个特殊的背书节点角色，或背书者。背书节点的特殊功能是关于特殊链码，存在于提交之前背书一个交易。每个链码可以指定一个背书策略，可以引用一组背书节点。策略定义一个有效交易背书的必要和充分条件（典型的是一组背书者签名）。在部署交易的特殊情况下，安装链码（部署）背书策略是由系统链码的背书策略指定。


### Orderer节点

排序者产生排序服务，即，一个提供交付保证的通信架构。

排序服务为客户端和peer节点提供共享的通信信道，为包含交易的消息提供广播服务。客户端连接到信道，可以在信道上广播消息，信道随后传递消息给所有peer节点。信道支持所有消息的原子传递，意思是，全部排序交付的消息通信和（具体实施）可靠性。换句话说，信道输出同样的消息给所有连接的peer节点并且输出的消息具有同样的逻辑顺序。这个原子通信保证也称为全部排序广播，原子广播，或是分布式系统中的共识。通信消息是包含在区块链状态中的申请交易。

分隔（排序服务信道）。排序服务可以支持多个信道，类似发布/订阅主题消息系统。客户端能够连接到一个给定的信道，然后能够发送消息和获得到达的消息。信道能够被认为是分区-客户端连接到一个信道而没有察觉到其它信道的存在，但客户端可以连接到多个信道。


# 交易背书的基本工作流程

接下来我们概述一个交易的高级请求流程

## 客户端创建交易和发送给它选择的背书peer节点

`PROPOSE`消息格式是`<PROPOSE,tx,[anchor]>`

* tx=<clientID,chaincodeID,txPayload,timestamp,clientSig>
  
  * clientID: 提交客户端ID
  * chaincodeID：引用交易的链码
  * txPayload: 交易本身的负载
  * timestamp: 时间戳
  * clientSig: 客户端签名

  对于调用交易，txPayload详情

  * txPayload = <operation, metadata>
    * operation: 链码的函数和参数 
    * metadata: 相关属性

  对于部署交易, txPayload详情

  * txPayload = <source, metadata, policies>
    * source: 链码的源码
    * metadata: 相关属性
    * policies: 包含所有peer节点可访问的链码的相关策略，像背书策略。注意背书策略在部署交易中不支持txPayload，但部署的txPayload包含背书策略ID和它的参数

* anchor: anchor包含读版本依赖，或更具体地说，键-版本对（即，anchor是KxN的一个子集），它捆绑或“锚”PROPOSE请求到指定KVS中key的版本。如果客户端指定anchor参数，背书者背书交易的情况是，只基于读它本地KVS匹配anchor中的相应KEY的版本号。


## 背书peer节点模拟交易和产生背书签名

在从客户端接收消息时，背书peer节点epID首先校验客户端签名clientSig，然后模拟一个交易。如果客户端指定了anchor，那么背书peer节点模拟交易只基于在它本地KVS匹配的由anchor指定的版本号对应的key读版本号（即，下面定义的readset）。

模拟一个交易涉及背书节点尝试执行一个交易(txPayload), 通过调用链码到交易引用（chaincodeID）和背书peer节点本地持有的状态拷贝。

作为执行的结果，背书peer节点计算读版本依赖（readset）和状态更新（writeset），也在DB语言中称为MVCC+postimage info。

回顾状态包含键/值对。所有键/值对实体都是版本化的，那就是说，每个实体包含排序版本信息，它是在每次键的值更新时增加的。解释交易的peer节点记录了所有的被链码访问的键/值对，不管读或是写，peer节点不会更新它的状态。更具体地说：

* 在背书节点执行一个交易前给定状态s，被交易读取的每个键k，键/值对(k,s(k).version)被添加到readset。

* 此外，对于每一个被交易编辑的键k到值v’，键/值对(k,v’)被添加到writeset。或者，v’能成为新值与前值(s(k).value)的增量。


如果客户端在PROPOSE消息中指定了anchor，那么客户端指定的anchor在模拟交易时必须等于背书peer节点产生的readset。

它的逻辑部分来背书交易，称为背书逻辑。缺省时，一个peer节点的背书逻辑接受交易提案并简单签署。无论如何，背书逻辑可以执行任意功能，到，例如，与原有系统交互交易提案和tx作为输入来得知是否背书交易。

如果背书逻辑决定背书一个交易，它发送消息`<TRANSACTION-ENDORSED, tid, tran-proposal,epSig> `消息到提交客户端`(tx.clientID)`,

* tran-proposal := (epID,tid,chaincodeID,txContentBlob,readset,writeset) , 其中 txContentBlob 是链码/交易专用信息。目的是让txContentBlob 用作tx的一些陈述 (例如, txContentBlob=tx.txPayload).
* epSig 是背书peer节点的交易提案签名

否则，假使背书逻辑拒绝背书交易，背书者可以发送消息`(TRANSACTION-INVALID, tid, REJECTED)`到提交客户端。


注意背书者在这一步不能改变它的状态，在背书没有影响状态的情况下交易模拟产生状态更新。


## 提交客户端收集交易背书并通过排序服务广播它

提交客户端一直等待直到它在(TRANSACTION-ENDORSED, tid, , )上收集到“足够”的消息和签名来推断出交易提案已背书


“足够”的准确数字取决于链码背书策略。如果背书策略是安全的，交易已经背书；注意它还没提交。签署TRANSACTION-ENDORSED消息的收集从背书peer节点来，背书peer节点建立了交易是背书的称为背书并以背书为名称。

如果提交客户端没有设法为交易提案收集背书，则放弃这个交易，稍后再试。

对于一个具有有效背书的交易，我们现在开始使用排序服务。提交客户端使用broadcast(blob)调用排序服务，其中blob=endorsement.如果客户端没有能力直接调用排序服务，它可以通过它选择的peer节点代理广播。这样的peer节点必须被客户端信任不会从背书移除任何消息或其它可能被无效的交易。注意一点，无论如何，代理peer节点不可能制造有效背书。


## 排序服务向peer节点提交交易

当一个事件deliver(seqno, prevhash, blob)发生并且一个peer节点已为所有序列号低于seqno的blosbs更新状态，peer节点执行如下流程：

* 它检查blob.endorsement是有效的，根据的是它引用的链码(blob.tran-proposal.chaincodeID)。

* 在典型情况下，它也验证了依赖(blob.endorsement.tran-proposal.readset)在期间没有被违反。在更复杂的用例中，背书中的交易提案域可能不同，在这种情况下，背书策略指定状态如何形成。

依赖的验证能以不同的方式实现，根据一致性属性或为状态更新选择的“隔离保证”。Serializability是一个缺省的隔离保证，除非链码背书策略指定一个不同的。Serializability能够通过在readset中的每个key关联的版本被提供，相当于key在状态中的版本，并拒绝不满足这个要求的交易。

* 如果所有这些检查通过，交易被视为有效或承诺。在这种情况下，peer节点在PeerLedger用1标记交易，适用于blob.endorsement.tran-proposal.writeset区块链状态（如果交易提案是相同的，其它背书策略逻辑定义了函数处理blob.endorsement）。

* 如果blob.endorsement背书策略验证失败，交易无效，并且peer节点在PeerLedger的位掩码用0标记交易。重要的是要注意无效交易不会改变状态。

注意，这里有足够的让所有（正确）peer节点在处理一个给定序列号的deliver事件（块）之后具有同样的状态。即，通过排序服务的保证，所有正确的peer节点会收到相同的deliver(seqno, prevhash, blob)事件序列。当背书策略的评估和readset中版本依赖的评估是确定的，所有正确的peer节点也会得出相同的结论，关于包含在blob中的交易是否有效。因此，所有peer节点提交和应用同样交易序列并用同样的方式更新它们的状态。

注意，这里有足够的让所有（正确）peer节点在处理一个给定序列号的deliver事件（块）之后具有同样的状态。即，通过排序服务的保证，所有正确的peer节点会收到相同的deliver(seqno, prevhash, blob)事件序列。当背书策略的评估和readset中版本依赖的评估是确定的，所有正确的peer节点也会得出相同的结论，关于包含在blob中的交易是否有效。因此，所有peer节点提交和应用同样交易序列并用同样的方式更新它们的状态。

![flow-4.png](images/flow-4.png)


# 背书策略

## 背书策略规范

背书策略，是背书一个交易的条件。区块链peer节点有一组预先确定的背书策略，它被安装特定链码的部署交易引用。背书策略能参数化，这些参数能被部署交易指定。

为了保证区块链和安全特性，背书策略组应该是一组验证过的策略，具有有限功能，为了保证有限的执行时间（终止），决定、性能和安全保证。

背书策略的动态添加（即，在链码部署时间由部署交易添加）是对背书评估时间限制（终止）、决定、性能和安全保证非常敏感的。因此，动态添加背书策略是不允许的，但将来能支持。

## 针对背书策略的交易评估

交易只有经过根据背书策略的背书才会宣布有效。对于链码的调用交易首先需要的到一个满足链码策略的背书，或不提交。这通过在提交客户端和背书peer节点之间的互动发生。

正式的背书策略是以背书为基础，以及潜在的进一步评估为真假状态。对于部署交易，获得背书的依据是系统系统范围策略（例如，来自系统链码）。


背书策略断言引用一定的变量。潜在可能引用的是：

1、与链码有关的Key或身份（在链码元数据中能发现），例如，一组背书者；

2、链码进一步的元数据；

3、endorsement and endorsement.tran-proposal的元素；

4、其它更多。

## 背书策略例子

断言可以包含逻辑表达式和评估真假。通常情况会对背书节点为链码发出的交易请求使用数字签名。

假定链码指定背书者集E = {Alice, Bob, Charlie, Dave, Eve, Frank, George}.一些例子策略如下：

* 一个有效签名来自全体E的成员的同样的交易提案。
* 一个有效签名来自E的任一单个成员。
* 从背书peer节点来的同一交易提案的有效签名条件是：(Alice OR Bob) AND (any two of: Charlie, Dave, Eve, Frank, George).
* 同一提案的有效签名为7名背书者的任意5名。（更常用的，链码n>3f背书者，n名背书者有任意2f+1有效签名，或任意大于(n+f)/2背书者小组有效签名）
* 假定背书者有一个“股份”或“权重”的任务，像{Alice=49, Bob=15, Charlie=15, Dave=10, Eve=7, Frank=3, George=1}, 其中全部股份是100：策略需要一组占大多数股份的有效签名（即，一组合并股份完全超过50），像{Alice, X}，X只要不是George的任何人，或{除去Alice以外的所有人}，等等。
* 假定前面例子中的股权条件是静态的（固定在链码的元数据中）或动态的（例如，取决于链码的状态和在执行中修改）。
* 交易提案1的有效签名来自(Alice OR Bob) 和交易提案2有效签名来自（Charlie, Dave, Eve, Frank, George中的任何两个），其中交易提案1和交易提案2的不同只在它们的背书peer节点和状态更新。

# (post-v1). 证实账本和节点账本检查（修剪）(Validated ledger and PeerLedger checkpointing (pruning))

## 验证账本

维护一个账本的抽象，只包含有效和提交交易（例如比特币的方案），peer节点可以，除状态和账本外，维护证实账本（或VLedger）。这是一个哈希链，来自过滤掉无效交易的账本。

证实账本块的生成按如下顺序。当节点账本块可能包含无效交易（即，交易的背书无效或版本依赖无效），这样的交易被peer节点在交易从块变为证实块之前过滤掉。每个peer节点自身实现这点（例如，使用节点账本关联的位掩码）。证实块被定义为没有无效交易的块，是进过过滤的块。这样证实块在大小上是动态的也可能是空的。证实块生成的说明在下图中给出。

![blocks-3.png](images/blocks-3.png)

证实块被每个peer节点链接在一起形成一个哈希链。更具体地，证实账本的每个块包含：

* 前证实块的哈希。
* 证实块编号。
* 从上一个证实块被计算出以来所有peer节点提交交易的排序列表（即，在相应块中的有效交易列表）。
* 相应块的哈希（在节点账本中），来自得出的当前证实块。

所有这些信息都被peer节点级联和哈希，产生证实账本中证实块的哈希。


## 节点账本检查

账本包含的无效交易，没有必要永久记录。然而，一旦建立相应的证实块，peer节点不能简单地丢弃节点账本块从而修剪节点账本。即，在这种情况下，如果新的peer节点加入了网络，其它peer节点不能转移丢弃块（与节点账本有关的）到新加入的节点，也不能使新加入的peer节点承认它们的证实块。

为了便于节点账本修剪，这个文档描述一个检查点机制。这个机制建立了证实块的有效性，贯穿节点网络，允许检查点证实块替换丢弃的节点账本块。这，反过来，减少了存储空间，因为没有必要存储无效交易。它也减少了新加入的peer节点重构状态的工作量（当通过重演节点账本重构状态时，因为他们不需要建立有效的单个交易，但可以简单重演包含在节点账本中的状态更新。）

## 检查点协议

检查点是由peer节点每个CHK块周期性地形成，这里CHK是一个可配置参数。开辟一个检查点，peer节点广播（例如，传播）给其它peer节点 , 其中，blockno是当前块编号，blocknohash是各自的哈希，stateHash是最新状态的哈希（产生于，例如Merkle hash），基于确认的块编号，peerSig是peer节点的对(CHECKPOINT,blocknohash,blockno,stateHash)的签名，引用了证实账本。

peer节点收集CHECKPOINT消息直到它得到匹配blockno, blocknohash 和 stateHash 的足够正确的签名消息来建立一个有效的检查点。（见4.2.2节）

在为块编号blockno 和 blocknohash建立了有效的检查点的基础上，peer节点： - 如果 blockno>latestValidCheckpoint.blockno, 那么peer节点分配 latestValidCheckpoint=(blocknohash,blockno), - 存储各peer节点的签名集，它构成了有效的检查点到集合latestValidCheckpointProof, - 存储状态相应的stateHash 到 latestValidCheckpointedState, - （可选的）修剪它的节点账本到块编blockno (包含).


##  有效检查点

显然，检查点协议增加了下面的问题：peer节点什么时候能修剪它的节点账本？多少检查点消息是足够多的？这由检查点有效策略定义，要有（至少）两种可能的方法且也能合并：

* Local (peer-specific) checkpoint validity policy (LCVP).给定peer节点p上的本地策略可以确定一组peer节点，这一组peer节点是p信任的且它的CHECKPOINT消息是足够建立一个有效的检查点。例如，在peer节点Alice上的LCVP可以定义本地（peer确定）检查点有效性策略（LCVP）。
* Global checkpoint validity policy (GCVP).检查点有效策略可以确定为全局的。这类似于本地节点策略，除非在系统链间隔上规定，好于节点间隔。例如，GCVP可以指定：
* 每个peer节点可以信任一个由11各不同peer节点确认的检查点。
* 在具体部署中每个排序者与peer节点配置在同一台机器上（即，信任域），多达f个排序者可以是（拜占庭）错误，每个peer节点可以信任一个检查点，如果经过f+1个排序者配置的不同的节点确认。